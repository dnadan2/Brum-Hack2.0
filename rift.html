<!doctype html>
<html lang="en">
<head>
  <title>Treehouse Logo in three.js</title>
  <meta charset="utf-8">
</head>
<body style="margin: 0;">

  <script src="js/three.js"></script>
  <script src="js/OrbitControls.js"></script>
  <script src="js/PointerLockControls.js"></script>
  <script src="js/threex.universalloader.js"></script>
  <script src="js/ColladaLoader.js"></script>
  <script src="js/OculusRiftEffect.js"></script>
  <script src="js/scene.js"></script>

  <script>


var VR_POSITION_SCALE = 25;

      function printVector(values) {
        if (values == null)
          return "null";

        var str = "[";

        str += values.x.toFixed(2) + ", ";
        str += values.y.toFixed(2) + ", ";
        str += values.z.toFixed(2);

        if ("w" in values) {
          str += ", " + values.w.toFixed(2);
        }

        str += "]";
        return str;
      }

      //
      // WebVR Device initialization
      //
      var sensorDevice = null;
      var hmdDevice = null;
      var vrMode = false;
      var renderTargetWidth = 1920;
      var renderTargetHeight = 1080;
      var riftObj;

var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

      // Create the scene and set the scene size.
      scene = new THREE.Scene();
      var WIDTH = window.innerWidth,
          HEIGHT = window.innerHeight;

      // Create a renderer and add it to the DOM.
      renderer = new THREE.WebGLRenderer({antialias:true});
      renderer.setSize(WIDTH, HEIGHT);
      document.body.appendChild(renderer.domElement);



      function PerspectiveMatrixFromVRFieldOfView(fov, zNear, zFar) {
        var outMat = new THREE.Matrix4();
        var out = outMat.elements;
        var upTan, downTan, leftTan, rightTan;
        if (fov == null) {
          // If no FOV is given plug in some dummy values
          upTan = Math.tan(50 * Math.PI/180.0);
          downTan = Math.tan(50 * Math.PI/180.0);
          leftTan = Math.tan(45 * Math.PI/180.0);
          rightTan = Math.tan(45 * Math.PI/180.0);
        } else {
          upTan = Math.tan(fov.upDegrees * Math.PI/180.0);
          downTan = Math.tan(fov.downDegrees * Math.PI/180.0);
          leftTan = Math.tan(fov.leftDegrees * Math.PI/180.0);
          rightTan = Math.tan(fov.rightDegrees * Math.PI/180.0);
        }

        var xScale = 2.0 / (leftTan + rightTan);
        var yScale = 2.0 / (upTan + downTan);

        out[0] = xScale;
        out[4] = 0.0;
        out[8] = -((leftTan - rightTan) * xScale * 0.5);
        out[12] = 0.0;

        out[1] = 0.0;
        out[5] = yScale;
        out[9] = ((upTan - downTan) * yScale * 0.5);
        out[13] = 0.0;

        out[2] = 0.0;
        out[6] = 0.0;
        out[10] = zFar / (zNear - zFar);
        out[14] = (zFar * zNear) / (zNear - zFar);

        out[3] = 0.0;
        out[7] = 0.0;
        out[11] = -1.0;
        out[15] = 0.0;

        return outMat;
      }

      var cameraLeft = new THREE.PerspectiveCamera( 75, 4/3, 0.1, 1000 );
      var cameraRight = new THREE.PerspectiveCamera( 75, 4/3, 0.1, 1000 );

      var fovScale = 1.0;
      function resizeFOV(amount) {
        var fovLeft, fovRight;

        if (!hmdDevice) { return; }

        if (amount != 0 && 'setFieldOfView' in hmdDevice) {
          fovScale += amount;
          if (fovScale < 0.1) { fovScale = 0.1; }

          fovLeft = hmdDevice.getRecommendedEyeFieldOfView("left");
          fovRight = hmdDevice.getRecommendedEyeFieldOfView("right");

          fovLeft.upDegrees *= fovScale;
          fovLeft.downDegrees *= fovScale;
          fovLeft.leftDegrees *= fovScale;
          fovLeft.rightDegrees *= fovScale;

          fovRight.upDegrees *= fovScale;
          fovRight.downDegrees *= fovScale;
          fovRight.leftDegrees *= fovScale;
          fovRight.rightDegrees *= fovScale;

          hmdDevice.setFieldOfView(fovLeft, fovRight);
        }

        if ('getRecommendedEyeRenderRect' in hmdDevice) {
          var leftEyeViewport = hmdDevice.getRecommendedEyeRenderRect("left");
          var rightEyeViewport = hmdDevice.getRecommendedEyeRenderRect("right");
          renderTargetWidth = leftEyeViewport.width + rightEyeViewport.width;
          renderTargetHeight = Math.max(leftEyeViewport.height, rightEyeViewport.height);
        }

        resize();

        if ('getCurrentEyeFieldOfView' in hmdDevice) {
          fovLeft = hmdDevice.getCurrentEyeFieldOfView("left");
          fovRight = hmdDevice.getCurrentEyeFieldOfView("right");
        } else {
          fovLeft = hmdDevice.getRecommendedEyeFieldOfView("left");
          fovRight = hmdDevice.getRecommendedEyeFieldOfView("right");
        }

        cameraLeft.projectionMatrix = PerspectiveMatrixFromVRFieldOfView(fovLeft, 0.1, 1000);
        cameraRight.projectionMatrix = PerspectiveMatrixFromVRFieldOfView(fovRight, 0.1, 1000);
      }

      function resetSensor() {
        if (sensorDevice) {
          if ('resetSensor' in sensorDevice) {
            sensorDevice.resetSensor();
          } else if ('zeroSensor' in sensorDevice) {
            sensorDevice.zeroSensor();
          }
        }
      }

      function EnumerateVRDevices(devices) {
        // First find an HMD device
        for (var i = 0; i < devices.length; ++i) {
          if (devices[i] instanceof HMDVRDevice) {
            hmdDevice = devices[i];

            var eyeOffsetLeft = hmdDevice.getEyeTranslation("left");
            var eyeOffsetRight = hmdDevice.getEyeTranslation("right")

            cameraLeft.position.add(eyeOffsetLeft);
            cameraLeft.position.z = 12;

            cameraRight.position.add(eyeOffsetRight);
            cameraRight.position.z = 12;

            resizeFOV(0.0);
          }
        }

        // Next find a sensor that matches the HMD hardwareUnitId
        for (var i = 0; i < devices.length; ++i) {
          if (devices[i] instanceof PositionSensorVRDevice &&
               (!hmdDevice || devices[i].hardwareUnitId == hmdDevice.hardwareUnitId)) {
            sensorDevice = devices[i];
            resetSensor();
          }
        }
      }

      if (navigator.getVRDevices) {
        navigator.getVRDevices().then(EnumerateVRDevices);
      } else if (navigator.mozGetVRDevices) {
        navigator.mozGetVRDevices(EnumerateVRDevices);
      }

      window.addEventListener("keydown", function(ev) {
        if (hmdDevice) {
          if (ev.keyCode == "R".charCodeAt(0))  {
            resetSensor();
          }
          if (ev.keyCode == 187 || ev.keyCode == 61)  { // "+" key
            resizeFOV(0.1);
          }
          if (ev.keyCode == 189 || ev.keyCode == 173)  { // "-" key
            resizeFOV(-0.1);
          }
        }
      });


      function resize() {
        if (vrMode) {
          camera.aspect = renderTargetWidth / renderTargetHeight;
          camera.updateProjectionMatrix();
          renderer.setSize( renderTargetWidth, renderTargetHeight );
        } else {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize( window.innerWidth, window.innerHeight );
        }
      }
      resize();
      window.addEventListener("resize", resize, false);

      renderer.domElement.addEventListener("touchstart", function(ev) {
        resetSensor();
      });

      // Fullscreen VR mode handling

      function onFullscreenChange() {
        if(!document.webkitFullscreenElement && !document.mozFullScreenElement) {
          vrMode = false;
        }
        resize();
      }

      document.addEventListener("webkitfullscreenchange", onFullscreenChange, false);
      document.addEventListener("mozfullscreenchange", onFullscreenChange, false);

function updateVRDevice() {
        if (!sensorDevice) return false;
        var vrState = sensorDevice.getState();

        if (riftObj) {
          if (vrState.position) {
            riftObj.position.x = vrState.position.x * VR_POSITION_SCALE;
            riftObj.position.y = vrState.position.y * VR_POSITION_SCALE;
            riftObj.position.z = vrState.position.z * VR_POSITION_SCALE;
          }

          if (vrState.orientation) {
            riftObj.quaternion.x = vrState.orientation.x;
            riftObj.quaternion.y = vrState.orientation.y;
            riftObj.quaternion.z = vrState.orientation.z;
            riftObj.quaternion.w = vrState.orientation.w;
          }
        }

        return true;
      }



    // Set up the scene, camera, and renderer as global variables.
    var scene, camera, renderer;

var effect, objects={};

    init();
    animate();

    // Sets up the scene.
    function init() {

      // Create a camera, zoom it out from the model a bit, and add it to the scene.
//      camera = new THREE.PerspectiveCamera(45, WIDTH / HEIGHT, 0.1, 20000);
//      camera.position.set(0,6,0);
//      scene.add(camera);

      // Set the background color of the scene.
      renderer.setClearColor(0x333F47, 1);

      // Create a light, set its position, and add it to the scene.
      var light = new THREE.PointLight(0xffe5c9);
      light.position.set(-2,2,0);
      scene.add(light);
      var light2 = new THREE.PointLight(0xffe5c9);
      light2.position.set(-1,2,0);
//      scene.add(light2);
      var light3 = new THREE.PointLight(0xffe5c9);
      light3.position.set(-3.5,1,-1);
      scene.add(light3);

      loadScene();

      // Add OrbitControls so that we can pan around with the mouse.
//      controls = new THREE.OrbitControls(camera, renderer.domElement);
//      controls = new THREE.PointerLockControls(camera);
      //Oculus Rift Effect
//      effect = new THREE.OculusRiftEffect(renderer);

    }

    // Renders the scene and updates the render as needed.
    function animate() {

      // Read more about requestAnimationFrame at http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/
      requestAnimationFrame(animate);
      




if (!updateVRDevice()) {
          // If we don't have a VR device just spin the model around to give us
          // something pretty to look at.
          if (objects['bed'].rotation) {
            objects['bed'].rotation.y += 0.01;
          }
        }

if (vrMode) {
          // Render left eye
          renderer.enableScissorTest ( true );
          renderer.setScissor( 0, 0, renderTargetWidth / 2, renderTargetHeight );
          renderer.setViewport( 0, 0, renderTargetWidth / 2, renderTargetHeight );
          renderer.render(scene, cameraLeft);

          // Render right eye
          renderer.setScissor( renderTargetWidth / 2, 0, renderTargetWidth / 2, renderTargetHeight );
          renderer.setViewport( renderTargetWidth / 2, 0, renderTargetWidth / 2, renderTargetHeight );
          renderer.render(scene, cameraRight);
        } else {
          // Render mono view
          renderer.enableScissorTest ( false );
          renderer.setViewport( 0, 0, window.innerWidth, window.innerHeight );
          renderer.render(scene, camera);
        }

      



      // Render the scene.
  //    effect.render(scene, camera);
      //controls.update();

    }

  </script>

</body>
</html>
